路径: ../backend/requirements.txt
代码内容:
alpha_vantage==2.3.1
yfinance==0.2.50
pycoingecko==3.1.0
django==4.2.0
djangorestframework==3.14.0
django-cors-headers==4.1.0
djangorestframework-simplejwt==5.2.2
python-dotenv==1.0.0
psycopg2-binary==2.9.6 
python-binance==1.0.22
requests
beautifulsoup4


路径: ../backend/Dockerfile
代码内容:
FROM python:3.9

WORKDIR /app

RUN apt-get update && apt-get install -y netcat-openbsd

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

RUN chmod +x entrypoint.sh
RUN sed -i 's/\r$//g' entrypoint.sh

RUN useradd -m myuser
RUN chown -R myuser:myuser /app
USER myuser

ENTRYPOINT ["./entrypoint.sh"] 

路径: ../backend/.env
代码内容:
DJANGO_SECRET_KEY=your-secret-key-here
DEBUG=True
DOCKER_ENVIRONMENT=0 
ALPHA_VANTAGE_API_KEY=QKPJQ3HZ53427C66
BINANCE_API_KEY=sZPyBnoMx2e5uvYQnspXyCQxZwfkP4uaHEZ2k1sYa7Aa8WMd323V2LBeLv4h39xY
BINANCE_API_SECRET=bjaKS0esCrhKDvVxBfDscUr9jdZDQFhMJmhCNcdPmJYWFc2uD6lDAfBtFeBVhYaJ
XAI_API_KEY=xai-bhGS91zRWYxFVbb3N99O99pdMTY3EHaDh9wuGA30krmetRHWTUJZL4Rla4WRZWAE3bEzmSAjb2btDlCP

路径: ../backend/manage.py
代码内容:
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'portfolio_backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main() 

路径: ../backend/entrypoint.sh
代码内容:
#!/bin/sh

echo "Waiting for postgres..."
while ! nc -z db 5432; do
    sleep 0.1
done
echo "PostgreSQL started"

echo "Running migrations..."
python manage.py makemigrations
python manage.py migrate

echo "Creating superuser..."
python manage.py createsuperuser --noinput --username admin --email admin@example.com || true

echo "Starting Django server..."
python manage.py runserver 0.0.0.0:8000

路径: ../backend/users/models.py
代码内容:
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    email = models.EmailField(unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.username 

路径: ../backend/users/serializers.py
代码内容:
from rest_framework import serializers
from .models import User

class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'password')

    def create(self, validated_data):
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data['email'],
            password=validated_data['password']
        )
        return user 

路径: ../backend/users/__init__.py
代码内容:
# Empty file


路径: ../backend/users/apps.py
代码内容:
from django.apps import AppConfig

class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'users' 

路径: ../backend/users/admin.py
代码内容:
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import User

admin.site.register(User, UserAdmin) 

路径: ../backend/users/urls.py
代码内容:
from django.urls import path
from . import views

urlpatterns = [
    path('register/', views.register, name='register'),
] 

路径: ../backend/users/views.py
代码内容:
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.permissions import AllowAny
from .serializers import UserSerializer

@api_view(['POST'])
@permission_classes([AllowAny])
def register(request):
    serializer = UserSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 

路径: ../backend/users/migrations/__init__.py
代码内容:


路径: ../backend/users/migrations/0001_initial.py
代码内容:
# Generated by Django 4.2 on 2024-11-01 09:08

import django.contrib.auth.models
import django.contrib.auth.validators
from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):
    initial = True

    dependencies = [
        ("auth", "0012_alter_user_first_name_max_length"),
    ]

    operations = [
        migrations.CreateModel(
            name="User",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("password", models.CharField(max_length=128, verbose_name="password")),
                (
                    "last_login",
                    models.DateTimeField(
                        blank=True, null=True, verbose_name="last login"
                    ),
                ),
                (
                    "is_superuser",
                    models.BooleanField(
                        default=False,
                        help_text="Designates that this user has all permissions without explicitly assigning them.",
                        verbose_name="superuser status",
                    ),
                ),
                (
                    "username",
                    models.CharField(
                        error_messages={
                            "unique": "A user with that username already exists."
                        },
                        help_text="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.",
                        max_length=150,
                        unique=True,
                        validators=[
                            django.contrib.auth.validators.UnicodeUsernameValidator()
                        ],
                        verbose_name="username",
                    ),
                ),
                (
                    "first_name",
                    models.CharField(
                        blank=True, max_length=150, verbose_name="first name"
                    ),
                ),
                (
                    "last_name",
                    models.CharField(
                        blank=True, max_length=150, verbose_name="last name"
                    ),
                ),
                (
                    "is_staff",
                    models.BooleanField(
                        default=False,
                        help_text="Designates whether the user can log into this admin site.",
                        verbose_name="staff status",
                    ),
                ),
                (
                    "is_active",
                    models.BooleanField(
                        default=True,
                        help_text="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.",
                        verbose_name="active",
                    ),
                ),
                (
                    "date_joined",
                    models.DateTimeField(
                        default=django.utils.timezone.now, verbose_name="date joined"
                    ),
                ),
                ("email", models.EmailField(max_length=254, unique=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "groups",
                    models.ManyToManyField(
                        blank=True,
                        help_text="The groups this user belongs to. A user will get all permissions granted to each of their groups.",
                        related_name="user_set",
                        related_query_name="user",
                        to="auth.group",
                        verbose_name="groups",
                    ),
                ),
                (
                    "user_permissions",
                    models.ManyToManyField(
                        blank=True,
                        help_text="Specific permissions for this user.",
                        related_name="user_set",
                        related_query_name="user",
                        to="auth.permission",
                        verbose_name="user permissions",
                    ),
                ),
            ],
            options={
                "verbose_name": "user",
                "verbose_name_plural": "users",
                "abstract": False,
            },
            managers=[
                ("objects", django.contrib.auth.models.UserManager()),
            ],
        ),
    ]


路径: ../backend/portfolio/models.py
代码内容:
from django.db import models
from users.models import User

class Portfolio(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    name = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)

class Holding(models.Model):
    portfolio = models.ForeignKey(Portfolio, related_name='holdings', on_delete=models.CASCADE)
    symbol = models.CharField(max_length=10)
    shares = models.IntegerField()  # Number of shares held
    cost_basis = models.DecimalField(max_digits=10, decimal_places=2)  # Cost basis per share
    market_value = models.DecimalField(max_digits=10, decimal_places=2)  # Set to cost_basis initially

    def __str__(self):
        return f"{self.symbol} - Shares: {self.shares}, Cost Basis: {self.cost_basis}, Market Value: {self.market_value}"

class Transaction(models.Model):
    holding = models.ForeignKey(Holding, related_name='transactions', on_delete=models.CASCADE)
    trade_date = models.DateField()
    shares = models.IntegerField()  # Number of shares bought or sold
    price = models.DecimalField(max_digits=10, decimal_places=2)  # Price per share
    action = models.CharField(max_length=4, choices=[('BUY', 'Buy'), ('SELL', 'Sell')])

    def __str__(self):
        return f"{self.action} - {self.shares} shares at {self.price} on {self.trade_date}"

路径: ../backend/portfolio/serializers.py
代码内容:
from rest_framework import serializers
from .models import Portfolio, Holding, Transaction


class TransactionSerializer(serializers.ModelSerializer):
    symbol = serializers.CharField(source='holding.symbol', read_only=True)
    class Meta:
        model = Transaction
        fields = ['id', 'trade_date', 'shares', 'price', 'action', 'holding', 'symbol']
        extra_kwargs = {
            'holding': {'read_only': True}
        }

class HoldingSerializer(serializers.ModelSerializer):
    transactions = TransactionSerializer(many=True, read_only=True)

    class Meta:
        model = Holding
        fields = ['id', 'symbol', 'shares', 'cost_basis', 'market_value', 'transactions']

class PortfolioSerializer(serializers.ModelSerializer):
    holdings = HoldingSerializer(many=True, read_only=True)

    class Meta:
        model = Portfolio
        fields = ['id', 'name', 'created_at', 'holdings']

路径: ../backend/portfolio/__init__.py
代码内容:


路径: ../backend/portfolio/apps.py
代码内容:
from django.apps import AppConfig


class PortfolioConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "portfolio"


路径: ../backend/portfolio/admin.py
代码内容:
from django.contrib import admin

# Register your models here.
from .models import Portfolio, Holding

admin.site.register(Portfolio)
admin.site.register(Holding)


路径: ../backend/portfolio/tests.py
代码内容:
from django.test import TestCase

# Create your tests here.


路径: ../backend/portfolio/urls.py
代码内容:
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PortfolioViewSet, HoldingViewSet, TransactionViewSet
from .views import get_profit_history


router = DefaultRouter()
router.register(r'portfolios', PortfolioViewSet)
router.register(r'holdings', HoldingViewSet)
router.register(r'transactions', TransactionViewSet)

urlpatterns = [
    path('', include(router.urls)),
    path('profit-history/', get_profit_history, name='profit-history'),
]

路径: ../backend/portfolio/views.py
代码内容:
from rest_framework import viewsets, status
from rest_framework.response import Response
from .models import Portfolio, Holding, Transaction
from .serializers import PortfolioSerializer, HoldingSerializer, TransactionSerializer
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import api_view, permission_classes
from market.models import PriceHistory
from django.utils.timezone import now
from datetime import timedelta
from market.models import PriceHistory

import logging

logger = logging.getLogger(__name__)

def recalculate_holding(holding):
    """
    Recalculate the holding's shares and cost_basis based on all associated transactions.
    """
    transactions = holding.transactions.all()
    total_shares = 0
    total_cost = 0

    for transaction in transactions:
        if transaction.action == 'BUY':
            total_shares += transaction.shares
            total_cost += transaction.shares * transaction.price
        elif transaction.action == 'SELL':
            total_shares -= transaction.shares

    holding.shares = total_shares
    holding.cost_basis = (total_cost / total_shares) if total_shares > 0 else 0
    latest_price = (
        PriceHistory.objects.filter(asset__symbol=holding.symbol)
        .order_by('-date')
        .first()
    )
    if latest_price:
        holding.market_value = total_shares * latest_price.close_price
    else:
        holding.market_value = 0
        
    holding.save()

class TransactionViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    queryset = Transaction.objects.all()
    serializer_class = TransactionSerializer

    def create(self, request, *args, **kwargs):
        symbol = request.data.pop('symbol', None)
        serializer = self.get_serializer(data=request.data)
        
        if serializer.is_valid():
            if symbol is None:
                return Response({'error': 'Symbol is required'}, status=status.HTTP_400_BAD_REQUEST)
            
            # Retrieve or create Portfolio and Holding
            portfolio, created = Portfolio.objects.get_or_create(user=request.user)
            holding, holding_created = Holding.objects.get_or_create(
                portfolio=portfolio,
                symbol=symbol,
                defaults={'shares': 0, 'cost_basis': 0, 'market_value': 0}
            )

            # Save transaction and recalculate holding
            transaction = serializer.save(holding=holding)
            recalculate_holding(holding)
            logger.info("Transaction created and holding recalculated: %s", serializer.data)
            return Response(TransactionSerializer(transaction).data, status=status.HTTP_201_CREATED)

        logger.warning("Transaction creation failed: %s", serializer.errors)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def update(self, request, *args, **kwargs):
        transaction = self.get_object()
        holding = transaction.holding

        # Update transaction data
        serializer = self.get_serializer(transaction, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        transaction = serializer.save()  # Save updated transaction

        # Recalculate holding based on all transactions
        recalculate_holding(holding)
        logger.info("Transaction updated and holding recalculated: %s", serializer.data)
        return Response(serializer.data, status=status.HTTP_200_OK)
    
    def destroy(self, request, *args, **kwargs):
        transaction = self.get_object()
        holding = transaction.holding

        # Delete transaction and recalculate holding
        transaction.delete()
        recalculate_holding(holding)
        logger.info("Transaction deleted and holding recalculated")
        return Response(status=status.HTTP_204_NO_CONTENT)
    
class PortfolioViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    queryset = Portfolio.objects.all()
    serializer_class = PortfolioSerializer
    
class HoldingViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    queryset = Holding.objects.all()
    serializer_class = HoldingSerializer
    
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_profit_history(request):
    def calculate_profit_history(user, symbol=None, start_date=None, end_date=None):
        # 获取用户的交易记录和历史价格
        transactions = Transaction.objects.filter(holding__portfolio__user=user)
        if symbol:
            transactions = transactions.filter(holding__symbol=symbol)
        if start_date and end_date:
            transactions = transactions.filter(trade_date__range=[start_date, end_date])

        # 获取相关的历史价格
        symbols = transactions.values_list('holding__symbol', flat=True).distinct()
        price_history = PriceHistory.objects.filter(
            asset__symbol__in=symbols,
            date__range=[start_date, end_date]
        ).order_by('date')

        # 初始化变量
        daily_holdings = {symbol: {'shares': 0, 'total_cost': 0} for symbol in symbols}
        profit_history = []

        # 按日期排序的交易和价格
        transactions = transactions.order_by('trade_date')
        date_range = price_history.values_list('date', flat=True).distinct()

        for date in date_range:
            # 按日期应用交易，更新持仓状态
            for transaction in transactions.filter(trade_date=date):
                symbol = transaction.holding.symbol
                if transaction.action == 'BUY':
                    daily_holdings[symbol]['shares'] += transaction.shares
                    daily_holdings[symbol]['total_cost'] += transaction.shares * transaction.price
                elif transaction.action == 'SELL':
                    daily_holdings[symbol]['shares'] -= transaction.shares
                    # 按成本比例减少总成本
                    avg_cost = daily_holdings[symbol]['total_cost'] / daily_holdings[symbol]['shares']
                    daily_holdings[symbol]['total_cost'] -= transaction.shares * avg_cost

            # 计算当天的总市值和收益
            total_value = 0
            total_cost = 0
            for symbol, holding in daily_holdings.items():
                shares = holding['shares']
                cost = holding['total_cost']
                price_data = price_history.filter(asset__symbol=symbol, date=date).first()
                if shares > 0 and price_data:
                    total_value += shares * price_data.close_price
                    total_cost += cost

            profit_history.append({
                'date': date,
                'total_value': total_value,
                'profit': total_value - total_cost
            })

        return profit_history

    """
    Get the profit history of a user's holdings.
    Supports filtering by time range and specific asset.
    """
    user = request.user
    start_date = request.query_params.get('start_date')
    end_date = request.query_params.get('end_date')
    symbol = request.query_params.get('symbol')

    # Default to query the last 30 days of data
    if not start_date:
        start_date = (now() - timedelta(days=30)).date()
    if not end_date:
        end_date = now().date()

    # # Get the user's portfolios
    # portfolios = Portfolio.objects.filter(user=user)
    # holdings = Holding.objects.filter(portfolio__in=portfolios)

    # if symbol:
    #     holdings = holdings.filter(symbol=symbol)

    # # Get historical price data
    # symbols = holdings.values_list('symbol', flat=True)
    # price_history = PriceHistory.objects.filter(
    #     asset__symbol__in=symbols,
    #     date__range=[start_date, end_date]
    # ).order_by('date')

    # # Build profit history data
    # profit_history = []
    # for date in price_history.values_list('date', flat=True).distinct():
    #     total_value = 0
    #     total_cost = 0

    #     for holding in holdings:
    #         daily_price = price_history.filter(asset__symbol=holding.symbol, date=date).first()
    #         if daily_price:
    #             total_value += holding.shares * daily_price.close_price
    #             total_cost += holding.cost_basis * holding.shares

    #     profit_history.append({
    #         'date': date,
    #         'total_value': total_value,
    #         'profit': total_value - total_cost,
    #     })
    profit_history = calculate_profit_history(
        user=user,
        symbol=symbol,
        start_date=start_date,
        end_date=end_date
    )
    
    
    return Response(profit_history, status=200)

路径: ../backend/portfolio/migrations/__init__.py
代码内容:


路径: ../backend/portfolio/migrations/0001_initial.py
代码内容:
# Generated by Django 4.2 on 2024-11-01 17:55

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Holding',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('symbol', models.CharField(max_length=10)),
                ('shares', models.IntegerField()),
                ('cost_basis', models.DecimalField(decimal_places=2, max_digits=10)),
                ('market_value', models.DecimalField(decimal_places=2, max_digits=10)),
            ],
        ),
        migrations.CreateModel(
            name='Transaction',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('trade_date', models.DateField()),
                ('shares', models.IntegerField()),
                ('price', models.DecimalField(decimal_places=2, max_digits=10)),
                ('action', models.CharField(choices=[('BUY', 'Buy'), ('SELL', 'Sell')], max_length=4)),
                ('holding', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='transactions', to='portfolio.holding')),
            ],
        ),
        migrations.CreateModel(
            name='Portfolio',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=255)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.AddField(
            model_name='holding',
            name='portfolio',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='holdings', to='portfolio.portfolio'),
        ),
    ]


路径: ../backend/market/models.py
代码内容:
from django.db import models
from users.models import User
from django.conf import settings
from django.utils.timezone import now


class Asset(models.Model):
    symbol = models.CharField(max_length=10, unique=True)
    name = models.CharField(max_length=255, unique=True )
    logo_url = models.URLField(blank=True, null=True)
    market_type = models.CharField(max_length=20)  
    last_refreshed = models.DateTimeField(auto_now=True) 

class PriceHistory(models.Model):
    asset = models.ForeignKey(Asset, on_delete=models.CASCADE, related_name='price_history')
    date = models.DateField()
    open_price = models.DecimalField(max_digits=10, decimal_places=2)
    close_price = models.DecimalField(max_digits=10, decimal_places=2)
    high_price = models.DecimalField(max_digits=10, decimal_places=2)
    low_price = models.DecimalField(max_digits=10, decimal_places=2)
    volume = models.BigIntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True) 
    change_24h = models.DecimalField(max_digits=6, decimal_places=2, null=True, blank=True)     
    market_cap = models.BigIntegerField(null=True, blank=True)  

    class Meta:
        unique_together = ('asset', 'date') 
class WatchlistItem(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,  
        on_delete=models.CASCADE,
        related_name="watchlist",  
        verbose_name="User"
    )
    symbol = models.CharField(
        max_length=10,
        verbose_name="Asset Symbol"
    )
    added_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name="Added At"
    )

    class Meta:
        unique_together = ('user', 'symbol')  
        ordering = ['-added_at']  
        verbose_name = "Watchlist Item"
        verbose_name_plural = "Watchlist Items"

    def __str__(self):
        return f"{self.user.username} - {self.symbol}"
class WorldIndex(models.Model):
    region = models.CharField(max_length=100)
    symbol = models.CharField(max_length=50)
    price = models.DecimalField(max_digits=12, decimal_places=2)
    change = models.CharField(max_length=20)  # Store as a string to keep percentage
    last_updated = models.DateTimeField(default=now)
    class Meta:
        unique_together = ('region', 'symbol')  # Ensure unique region-symbol pair

    def __str__(self):
        return f"{self.region} - {self.symbol}"

class TopGainer(models.Model):
    symbol = models.CharField(max_length=10)
    name = models.CharField(max_length=255)
    price = models.DecimalField(max_digits=12, decimal_places=2)
    change_percent = models.CharField(max_length=10)

    def __str__(self):
        return f"{self.symbol} ({self.name})"


class TopLoser(models.Model):
    symbol = models.CharField(max_length=10)
    name = models.CharField(max_length=255)
    price = models.DecimalField(max_digits=12, decimal_places=2)
    change_percent = models.CharField(max_length=10)

    def __str__(self):
        return f"{self.symbol} ({self.name})"



路径: ../backend/market/serializers.py
代码内容:
from rest_framework import serializers
from .models import Asset, PriceHistory, WatchlistItem

class AssetSerializer(serializers.ModelSerializer):
    class Meta:
        model = Asset
        fields = ['id', 'symbol', 'name', 'logo_url', 'market_type', 'last_refreshed']

class PriceHistorySerializer(serializers.ModelSerializer):
    class Meta:
        model = PriceHistory
        fields = ['date', 'open_price', 'close_price', 'high_price', 'low_price', 'volume', 'price', 'change_24h', 'market_cap']

class WatchlistSerializer(serializers.ModelSerializer):
    user = serializers.StringRelatedField(read_only=True)
    class Meta:
        model = WatchlistItem
        fields = ['id', 'user', 'symbol', 'added_at']
        read_only_fields = ['id', 'user', 'added_at']

路径: ../backend/market/__init__.py
代码内容:


路径: ../backend/market/apps.py
代码内容:
from django.apps import AppConfig


class MarketConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "market"


路径: ../backend/market/admin.py
代码内容:
from django.contrib import admin
from .models import WatchlistItem, Asset, PriceHistory

admin.site.register(WatchlistItem)
admin.site.register(Asset)
admin.site.register(PriceHistory)

路径: ../backend/market/utils.py
代码内容:
from datetime import timedelta
from django.utils.timezone import now

REFRESH_INTERVAL = timedelta(hours=1) 

def should_refresh_data(last_refreshed):
    return (now() - last_refreshed) > REFRESH_INTERVAL


路径: ../backend/market/tests.py
代码内容:
from django.test import TestCase

# Create your tests here.


路径: ../backend/market/urls.py
代码内容:
# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AssetViewSet, MarketDataView, WatchlistViewSet
from . import views
from .views import check_and_update_world_indices, market_overview, chat_with_xai

router = DefaultRouter()
router.register(r'assets', AssetViewSet)
router.register(r'watchlist', WatchlistViewSet)

urlpatterns = [
    path('', include(router.urls)),
    path('<str:market>/<str:symbol>/', MarketDataView.as_view(), name='market-data'),
    path('check-update/', check_and_update_world_indices, name='check-update'),
    path('overview/', market_overview, name='market_overview'),
    path("chat-with-xai/", chat_with_xai, name="chat_with_xai"),

    # path('<str:market_type>/<str:symbol>/', views.AssetDetailView.as_view(), name='asset_detail'),

]


路径: ../backend/market/views.py
代码内容:
from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.utils.timezone import now
from .models import Asset, PriceHistory, WatchlistItem
from .serializers import AssetSerializer, PriceHistorySerializer, WatchlistSerializer
from .services import StockService, CryptoService
from .utils import should_refresh_data
from .services import get_market_service
from rest_framework.permissions import IsAuthenticated, AllowAny
from datetime import datetime
from rest_framework.decorators import api_view, permission_classes
import logging
from datetime import timedelta
from .scraper.market_scraper import scrape_and_save
from .models import WorldIndex, TopGainer, TopLoser
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json
import os
import requests


logger = logging.getLogger(__name__)

class AssetViewSet(viewsets.ModelViewSet):
    queryset = Asset.objects.all()
    serializer_class = AssetSerializer

    def retrieve(self, request, *args, **kwargs):
        asset = self.get_object()
        if should_refresh_data(asset.last_refreshed):
            self.refresh_data(asset)
        return super().retrieve(request, *args, **kwargs)

    def refresh_data(self, asset):
        service = self.get_service_for_asset(asset)
        service.update_price_history(asset)

    def get_service_for_asset(self, asset):
        if asset.market_type == 'stock':
            return StockService()
        elif asset.market_type == 'crypto':
            return CryptoService()

class MarketDataView(APIView):
    """
    Fetch market data for a specific asset and market type.
    If the asset doesn't exist in the database, it attempts to fetch and store it.
    """

    def get(self, request, market, symbol):
        asset = Asset.objects.filter(market_type=market, symbol=symbol.upper()).first()
        logger.info(f'asset: {asset}')
        if not asset:
            print('asset not found, fetching data from service')
            # Create a new asset record
            asset, _ = Asset.objects.get_or_create(
                market_type=market,
                symbol=symbol.upper(),
                name=symbol.upper() 
            )
            
            service = self.get_service_for_market(market)
            # Fetch historical data for the last 30 days
            service.fetch_price_history(asset, period="1mo", interval="1d")
        
        # load the appropriate service based on the market type
        latest_data = PriceHistory.objects.filter(asset=asset).order_by('-date').first()
        if not latest_data:
            # Fetch historical data for the last 30 days
            service = self.get_service_for_market(market)
            service.fetch_price_history(asset, period="1mo", interval="1d")
            latest_data = PriceHistory.objects.filter(asset=asset).order_by('-date').first()
        else:
            # Check if the current stored data is older than two days from the current time
            two_days_ago = datetime.now() - timedelta(days=2)
            logger.info(f'latest_data.date: {latest_data.date}, two_days_ago: {two_days_ago.date()}')
            if latest_data.date < two_days_ago.date():
                print('data is older than two days, refetching data from service')
                service = self.get_service_for_market(market)
                # Fetch historical data for the last 30 days
                service.fetch_price_history(asset, period="1mo", interval="1d")
                latest_data = PriceHistory.objects.filter(asset=asset).order_by('-date').first()
        # get historical data for the last 30 days
        historical_data = PriceHistory.objects.filter(asset=asset).order_by('-date')[:30] 
        historical_data_serialized = [
            {
                'date': record.date,
                'open_price': record.open_price,
                'close_price': record.close_price,
                'high_price': record.high_price,
                'low_price': record.low_price,
                'volume': record.volume,
            }
            for record in historical_data   
        ]
        
        # prepare the response data
        response_data = {
            'symbol': symbol,
            'price': latest_data.price,
            'change_24h': latest_data.change_24h,
            'volume': latest_data.volume,
            'market_cap': latest_data.market_cap,
            'historical_data': historical_data_serialized,
        }
        
        return Response(response_data, status=status.HTTP_200_OK)
    
    def get_service_for_market(self, market):
        if market == 'stock':
            return StockService()
        elif market == 'crypto':
            return CryptoService()
class AssetDetailView(APIView):
    def get(self, request, market_type, symbol):
        market_service = get_market_service(market_type)
        if not market_service:
            return Response({"error": "Market type not supported"}, status=status.HTTP_400_BAD_REQUEST)
        
        asset_data = market_service.get_current_data(symbol)
        if not asset_data:
            return Response({"error": "Asset data not found"}, status=status.HTTP_404_NOT_FOUND)
        
        return Response(asset_data, status=status.HTTP_200_OK)
    
class WatchlistViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    queryset = WatchlistItem.objects.all()
    serializer_class = WatchlistSerializer

    def get_queryset(self):
        return self.queryset.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    
    def list(self, request):
        """
        List all watchlist items for the authenticated user.
        """
        items = WatchlistItem.objects.filter(user=request.user)
        serializer = WatchlistSerializer(items, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def create(self, request):
        """
        Add a new asset to the user's watchlist.
        """
        symbol = request.data.get('symbol', '').upper()
        if not symbol:
            return Response({'error': 'Symbol is required.'}, status=status.HTTP_400_BAD_REQUEST)

        # Check if the asset already exists in the user's watchlist
        if WatchlistItem.objects.filter(user=request.user, symbol=symbol).exists():
            return Response({'error': 'Asset already in watchlist.'}, status=status.HTTP_400_BAD_REQUEST)

        watchlist_item = WatchlistItem.objects.create(user=request.user, symbol=symbol)
        serializer = WatchlistSerializer(watchlist_item)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def destroy(self, request, pk=None):
        """
        Remove an asset from the user's watchlist.
        """
        try:
            item = WatchlistItem.objects.get(user=request.user, pk=pk)
        except WatchlistItem.DoesNotExist:
            return Response({'error': 'Asset not found in watchlist.'}, status=status.HTTP_404_NOT_FOUND)

        item.delete()
        return Response({'message': f'Asset {item.symbol} removed from watchlist.'}, status=status.HTTP_204_NO_CONTENT)




@api_view(['GET'])
@permission_classes([AllowAny])
def check_and_update_world_indices(request):
    """
    check last updated time and update if necessary
    """
    last_updated = WorldIndex.objects.first().last_updated if WorldIndex.objects.exists() else None
    if not last_updated or now() - last_updated > timedelta(minutes=5):
        # if more than 5 minutes since last update, trigger update
        scrape_and_save()
        return Response({"status": "updated", "last_updated": now()})
    scrape_and_save()
    return Response({"status": "up-to-date", "last_updated": last_updated})

@api_view(['GET'])
@permission_classes([AllowAny])
def market_overview(request):
    try:
        world_indices = WorldIndex.objects.values('region', 'symbol', 'price', 'change')
        top_gainers = TopGainer.objects.values('symbol', 'name', 'price', 'change_percent')
        top_losers = TopLoser.objects.values('symbol', 'name', 'price', 'change_percent')

        return Response({
            'world_indices': list(world_indices),
            'top_gainers': list(top_gainers),
            'top_losers': list(top_losers),
        })
    except Exception as e:
        # print error log for debugging
        print(f"Error in market_overview view: {e}")
        return Response({'error': 'Internal Server Error'}, status=500)

@csrf_exempt
def chat_with_xai(request):
    if request.method == "POST":
        try:
            # get user input
            data = json.loads(request.body)
            user_message = data.get("message", "")
            
            # get XAI API key
            XAI_API_KEY = os.getenv("XAI_API_KEY")
            
            # define request headers and data
            url = "https://api.x.ai/v1/chat/completions"
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {XAI_API_KEY}"
            }
            payload = {
                "messages": [
                    {
                        "role": "system",
                        "content": "You name is ProfolioPro, an expert in portfolio management and finance. Answer questions concisely and informatively."
                    },
                    {
                        "role": "user",
                        "content": user_message
                    }
                ],
                "model": "grok-beta",
                "stream": False,
                "temperature": 0.7
            }

            # send request to XAI
            response = requests.post(url, json=payload, headers=headers)
            if response.status_code == 200:
                xai_response = response.json()
                message = xai_response["choices"][0]["message"]["content"]
                return JsonResponse({"response": message}, status=200)
            else:
                return JsonResponse({"error": response.text}, status=response.status_code)

        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)
    return JsonResponse({"error": "Invalid request method."}, status=405)

路径: ../backend/market/scraper/market_scraper.py
代码内容:
import requests
from bs4 import BeautifulSoup
from market.models import WorldIndex, TopGainer, TopLoser
from django.db import transaction
from django.utils.timezone import now

# Yahoo Finance URL and headers
YAHOO_FINANCE_URL = "https://finance.yahoo.com/markets/"
HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36"
}

def fetch_page_content(url):
    """Fetch and parse the page content from Yahoo Finance."""
    response = requests.get(url, headers=HEADERS)
    if response.status_code != 200:
        raise Exception(f"Failed to fetch data from Yahoo Finance. Status code: {response.status_code}")
    return BeautifulSoup(response.text, "html.parser")

def fetch_world_indices(soup):
    """Extract world indices data."""
    carousel = soup.find("div", {"class": "scroll-carousel"})
    if not carousel:
        raise Exception("Unable to locate the world indices section.")
    
    indices = []
    regions = carousel.find_all("section", {"data-testid": "world-indices"})
    for region in regions:
        region_name = region.find("h3").text.strip()
        table = region.find("table", {"class": "markets-table"})
        if not table:
            continue
        rows = table.find("tbody").find_all("tr")
        for row in rows:
            symbol = row.find("a", {"data-testid": "table-cell-ticker"}).text.strip()
            price = float(row.find("fin-streamer", {"data-field": "regularMarketPrice"}).text.replace(",", ""))
            change = row.find("fin-streamer", {"data-field": "regularMarketChangePercent"}).text.strip()
            indices.append({
                "region": region_name,
                "symbol": symbol,
                "price": price,
                "change": change,
            })
    return indices

def fetch_tops(soup, section_id):
    """Extract top gainers or top losers."""
    stocks = []
    section = soup.find("li", {"data-id": section_id})
    if not section:
        print(f"Section with id {section_id} not found.")
        return stocks

    rows = section.find_all("li", class_="dock-item primary font-default yf-46ugf5 clickability hover hasSymbolOptions")
    if not rows:
        print(f"No rows found in the section {section_id}.")
        return stocks

    for row in rows:
        try:
            symbol = row.find("span", class_="symbol").text.strip()
            name = row.find("span", class_="longName")["title"].strip()
            price = float(row.find("fin-streamer", {"data-field": "regularMarketPrice"})["data-value"])
            change_percent = float(row.find("fin-streamer", {"data-field": "regularMarketChangePercent"})["data-value"])
            stocks.append({
                "symbol": symbol,
                "name": name,
                "price": price,
                "change_percent": f"{change_percent:.2f}%"
            })
        except Exception as e:
            print(f"Error parsing row: {e}")
    return stocks

def save_to_db(data, model):
    """Save data to the specified model."""
    with transaction.atomic():
        model.objects.all().delete()  # Clear old data
        for item in data:
            try:
                model.objects.create(**item)
            except Exception as e:
                print(f"Error saving item to {model.__name__}: {e}")

def scrape_and_save():
    """Main function to scrape and save data."""
    print("Starting scrape_and_save...")
    try:
        soup = fetch_page_content(YAHOO_FINANCE_URL)

        # Fetch data
        world_indices = fetch_world_indices(soup)
        print(f"World Indices: {world_indices}")
        top_gainers = fetch_tops(soup, "topGainers")
        print(f"Top Gainers: {top_gainers}")
        top_losers = fetch_tops(soup, "topLosers")
        print(f"Top Losers: {top_losers}")

        # Save to database
        save_to_db(world_indices, WorldIndex)
        save_to_db(top_gainers, TopGainer)
        save_to_db(top_losers, TopLoser)

        print("Data scraped and saved successfully.")
    except Exception as e:
        print(f"Error during scraping and saving: {e}")


路径: ../backend/market/migrations/0007_sector_topgainer_toploser.py
代码内容:
# Generated by Django 4.2 on 2024-11-26 14:27

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('market', '0006_worldindex_last_updated'),
    ]

    operations = [
        migrations.CreateModel(
            name='Sector',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('sector_name', models.CharField(max_length=255)),
                ('market_weight', models.CharField(max_length=10)),
                ('ytd_return', models.CharField(max_length=10)),
            ],
        ),
        migrations.CreateModel(
            name='TopGainer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('symbol', models.CharField(max_length=10)),
                ('name', models.CharField(max_length=255)),
                ('price', models.DecimalField(decimal_places=2, max_digits=12)),
                ('change_percent', models.CharField(max_length=10)),
            ],
        ),
        migrations.CreateModel(
            name='TopLoser',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('symbol', models.CharField(max_length=10)),
                ('name', models.CharField(max_length=255)),
                ('price', models.DecimalField(decimal_places=2, max_digits=12)),
                ('change_percent', models.CharField(max_length=10)),
            ],
        ),
    ]


路径: ../backend/market/migrations/__init__.py
代码内容:


路径: ../backend/market/migrations/0005_worldindex.py
代码内容:
# Generated by Django 4.2 on 2024-11-26 11:31

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('market', '0004_alter_asset_name'),
    ]

    operations = [
        migrations.CreateModel(
            name='WorldIndex',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('region', models.CharField(max_length=100)),
                ('symbol', models.CharField(max_length=50)),
                ('price', models.DecimalField(decimal_places=2, max_digits=12)),
                ('change', models.CharField(max_length=20)),
            ],
            options={
                'unique_together': {('region', 'symbol')},
            },
        ),
    ]


路径: ../backend/market/migrations/0006_worldindex_last_updated.py
代码内容:
# Generated by Django 4.2 on 2024-11-26 14:03

from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):

    dependencies = [
        ('market', '0005_worldindex'),
    ]

    operations = [
        migrations.AddField(
            model_name='worldindex',
            name='last_updated',
            field=models.DateTimeField(default=django.utils.timezone.now),
        ),
    ]


路径: ../backend/market/migrations/0008_delete_sector.py
代码内容:
# Generated by Django 4.2 on 2024-11-27 03:33

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('market', '0007_sector_topgainer_toploser'),
    ]

    operations = [
        migrations.DeleteModel(
            name='Sector',
        ),
    ]


路径: ../backend/market/migrations/0003_alter_watchlistitem_options_and_more.py
代码内容:
# Generated by Django 4.2 on 2024-11-20 10:06

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ('market', '0002_pricehistory_change_24h_pricehistory_market_cap_and_more'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='watchlistitem',
            options={'ordering': ['-added_at'], 'verbose_name': 'Watchlist Item', 'verbose_name_plural': 'Watchlist Items'},
        ),
        migrations.AlterField(
            model_name='watchlistitem',
            name='added_at',
            field=models.DateTimeField(auto_now_add=True, verbose_name='Added At'),
        ),
        migrations.AlterField(
            model_name='watchlistitem',
            name='symbol',
            field=models.CharField(max_length=10, verbose_name='Asset Symbol'),
        ),
        migrations.AlterField(
            model_name='watchlistitem',
            name='user',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='watchlist', to=settings.AUTH_USER_MODEL, verbose_name='User'),
        ),
        migrations.AlterUniqueTogether(
            name='watchlistitem',
            unique_together={('user', 'symbol')},
        ),
    ]


路径: ../backend/market/migrations/0002_pricehistory_change_24h_pricehistory_market_cap_and_more.py
代码内容:
# Generated by Django 4.2 on 2024-11-07 08:31

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ('market', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='pricehistory',
            name='change_24h',
            field=models.DecimalField(blank=True, decimal_places=2, max_digits=6, null=True),
        ),
        migrations.AddField(
            model_name='pricehistory',
            name='market_cap',
            field=models.BigIntegerField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='pricehistory',
            name='price',
            field=models.DecimalField(blank=True, decimal_places=2, max_digits=10, null=True),
        ),
        migrations.CreateModel(
            name='WatchlistItem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('symbol', models.CharField(max_length=10)),
                ('added_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='watchlist', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]


路径: ../backend/market/migrations/0001_initial.py
代码内容:
# Generated by Django 4.2 on 2024-11-06 14:54

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Asset',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('symbol', models.CharField(max_length=10, unique=True)),
                ('name', models.CharField(max_length=255)),
                ('logo_url', models.URLField(blank=True, null=True)),
                ('market_type', models.CharField(max_length=20)),
                ('last_refreshed', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='PriceHistory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField()),
                ('open_price', models.DecimalField(decimal_places=2, max_digits=10)),
                ('close_price', models.DecimalField(decimal_places=2, max_digits=10)),
                ('high_price', models.DecimalField(decimal_places=2, max_digits=10)),
                ('low_price', models.DecimalField(decimal_places=2, max_digits=10)),
                ('volume', models.BigIntegerField()),
                ('asset', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='price_history', to='market.asset')),
            ],
            options={
                'unique_together': {('asset', 'date')},
            },
        ),
    ]


路径: ../backend/market/migrations/0004_alter_asset_name.py
代码内容:
# Generated by Django 4.2 on 2024-11-23 07:30

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('market', '0003_alter_watchlistitem_options_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='asset',
            name='name',
            field=models.CharField(max_length=255, unique=True),
        ),
    ]


路径: ../backend/market/services/stock_service.py
代码内容:
# services/stock_service.py
from .base_service import MarketService
import yfinance as yf
from ..models import PriceHistory, Asset
from datetime import datetime, timedelta

class StockService(MarketService):
    def get_current_data(self, asset):
        symbol = asset.symbol
        # Fetch stock data using yfinance
        stock = yf.Ticker(symbol)
        data = stock.history(period="1d")
        
        if not data.empty:
            latest_data = data.iloc[-1]
            return {
                'price': latest_data['Close'],
                'open': latest_data['Open'],
                'high': latest_data['High'],
                'low': latest_data['Low'],
                'volume': latest_data['Volume'],
                'date': latest_data.name.date()
            }
        return None

    def fetch_price_history(self, asset, period="1mo", interval="1d"):
        # Fetch historical price data with a specified period and interval
        symbol = asset.symbol
        if not symbol:
            raise ValueError("Symbol is required and cannot be None.")
        
        stock = yf.Ticker(symbol)
        history_data = stock.history(period=period, interval=interval)
        
        if not history_data.empty:
            asset, _ = Asset.objects.get_or_create(symbol=symbol.upper())
            history_records = {}
            last_close_price = None

            for date, row in history_data.iterrows():
                record_date = date.date()
                history_records[record_date] = {
                    'asset': asset,
                    'date': record_date,
                    'open_price': row['Open'],
                    'close_price': row['Close'],
                    'high_price': row['High'],
                    'low_price': row['Low'],
                    'volume': row['Volume'],
                    'price': row['Close'],
                    'change_24h': (row['Close'] - row['Open']) / row['Open'] * 100,
                    'market_cap': stock.info.get('marketCap', 0),
                }
                last_close_price = row['Close']
            # Fill missing weekend data
            start_date = min(history_records.keys())
            end_date = max(history_records.keys())
            current_date = start_date

            while current_date <= end_date:
                if current_date not in history_records and current_date.weekday() in [5, 6]:
                    # Fill weekend data
                    history_records[current_date] = {
                        'asset': asset,
                        'date': current_date,
                        'open_price': last_close_price,
                        'close_price': last_close_price,
                        'high_price': last_close_price,
                        'low_price': last_close_price,
                        'volume': 0,
                        'price': last_close_price,
                        'change_24h': 0,
                    }
                current_date += timedelta(days=1)

            # Insert data into the database
            PriceHistory.objects.bulk_create(
                [PriceHistory(**record) for record in history_records.values()],
                ignore_conflicts=True
            )

路径: ../backend/market/services/__init__.py
代码内容:
# backend/market/services/__init__.py

from .stock_service import StockService
from .crypto_service import CryptoService

def get_market_service(market_type):
    if market_type == 'stock':
        return StockService()
    elif market_type == 'crypto':
        return CryptoService()
    else:
        return None

路径: ../backend/market/services/base_service.py
代码内容:
from abc import ABC, abstractmethod
from market.models import Asset, PriceHistory

class MarketService(ABC):
    @abstractmethod
    def fetch_price_history(self, asset: Asset):
        """Fetch historical price data for the given asset."""
        pass

    def update_price_history(self, asset: Asset):
        """Update the database with the latest historical price data for the asset."""
        data = self.fetch_price_history(asset)
        for record in data:
            PriceHistory.objects.update_or_create(
                asset=asset,
                date=record['date'],
                defaults={
                    'open_price': record['open'],
                    'close_price': record['close'],
                    'high_price': record['high'],
                    'low_price': record['low'],
                    'volume': record['volume']
                }
            )


路径: ../backend/market/services/crypto_service.py
代码内容:
from .base_service import MarketService
from binance.client import Client
from pycoingecko import CoinGeckoAPI
from datetime import datetime, timedelta
from ..models import PriceHistory, Asset
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

class CryptoService(MarketService):
    def __init__(self):
        """
        Initialize Binance client and CoinGecko client using environment variables.
        """
        api_key = os.getenv("BINANCE_API_KEY")
        api_secret = os.getenv("BINANCE_API_SECRET")
        self.client = Client(api_key=api_key, api_secret=api_secret)
        self.cg = CoinGeckoAPI()
        self.symbol_to_id = self.get_symbol_to_id_mapping()

    def get_symbol_to_id_mapping(self):
        """
        Fetch and cache a mapping of base symbols to CoinGecko IDs.
        :return: A dictionary with symbols (e.g., 'BTC') as keys and CoinGecko IDs (e.g., 'bitcoin') as values.
        """
        try:
            coins_list = self.cg.get_coins_list()
            return {coin['symbol'].upper(): coin['id'] for coin in coins_list}
        except Exception as e:
            print(f"Error fetching CoinGecko coin list: {e}")
            return {}

    def get_coingecko_id(self, trading_pair):
        """
        Extract the base symbol from the trading pair (e.g., 'BTCUSDT') and get the CoinGecko ID.
        :param trading_pair: Binance trading pair symbol (e.g., 'BTCUSDT')
        :return: The corresponding CoinGecko ID (e.g., 'bitcoin') or None if not found.
        """
        try:
            base_symbol = trading_pair[:-4]  # Remove the last 4 characters (e.g., 'USDT', 'BUSD', etc.)
            return self.symbol_to_id.get(base_symbol.upper())
        except Exception as e:
            print(f"Error extracting CoinGecko ID for trading pair {trading_pair}: {e}")
            return None

    def get_current_data(self, asset):
        """
        Fetch the current price and market data for a specific trading pair.
        Automatically determine the CoinGecko ID based on the trading pair.

        :param symbol: The trading pair symbol (e.g., 'BTCUSDT')
        :return: A dictionary containing the latest price, open, high, low, volume, date, and market cap.
        """
        symbol = asset.symbol
        try:
            # Determine CoinGecko ID
            coingecko_id = self.get_coingecko_id(symbol)
            if not coingecko_id:
                print(f"CoinGecko ID not found for trading pair {symbol}")

            # Fetch current data from Binance
            ticker = self.client.get_ticker(symbol=symbol)
            current_data = {
                'price': float(ticker['lastPrice']),
                'open': float(ticker['openPrice']),
                'high': float(ticker['highPrice']),
                'low': float(ticker['lowPrice']),
                'volume': float(ticker['volume']),
                'date': datetime.utcfromtimestamp(int(ticker['closeTime']) / 1000).date(),
                'market_cap': None  # Default to None
            }

            # Fetch market cap from CoinGecko if ID is available
            if coingecko_id:
                market_cap = self.get_market_cap(coingecko_id)
                current_data['market_cap'] = market_cap

            return current_data
        except Exception as e:
            print(f"Error fetching current data for {symbol}: {e}")
            return None

    def fetch_price_history(self, asset, period="1mo", interval="1d", start_date=None, end_date=None):
        """
        Fetch historical price data for a specific cryptocurrency trading pair.

        :param symbol: The trading pair symbol (e.g., 'BTCUSDT')
        :param interval: The time interval for the data (e.g., '1m', '15m', '1h', '4h', '1d')
        :param start_date: The start date for fetching historical data in 'YYYY-MM-DD' format
        :param end_date: The end date for fetching historical data in 'YYYY-MM-DD' format
        """
        symbol = asset.symbol
        try:
            if start_date is None:
                start_date = (datetime.utcnow() - timedelta(days=30)).strftime('%Y-%m-%d')
            if end_date is None:
                end_date = datetime.utcnow().strftime('%Y-%m-%d')

            # Fetch historical kline (candlestick) data from Binance
            klines = self.client.get_historical_klines(
                symbol,
                interval,
                start_str=start_date,
                end_str=end_date
            )

            if klines:
                asset, _ = Asset.objects.get_or_create(symbol=symbol.upper())
                history_records = {}
                # Determine CoinGecko ID
                coingecko_id = self.get_coingecko_id(symbol)
                market_cap = self.get_market_cap(coingecko_id) if coingecko_id else None
                # Store fetched data in a dictionary with date as key
                for kline in klines:
                    date = datetime.utcfromtimestamp(kline[0] / 1000).date()
                    history_records[date] = {
                        'asset': asset,
                        'date': date,
                        'open_price': float(kline[1]),
                        'close_price': float(kline[4]),
                        'high_price': float(kline[2]),
                        'low_price': float(kline[3]),
                        'volume': float(kline[5]) * float(kline[4]),
                        'price': float(kline[4]),
                        'change_24h': ((float(kline[4]) - float(kline[1])) / float(kline[1])) * 100,
                        'market_cap': market_cap*float(kline[4]),
                    }
                # Fill missing weekend data
                start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
                end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
                current_date = start_date

                last_close_price = None
                while current_date <= end_date:
                    if current_date in history_records:
                        # Update last close price for weekdays
                        last_close_price = history_records[current_date]['close_price']
                    elif current_date.weekday() in [5, 6] and last_close_price is not None:
                        # Fill weekend data with last known close price
                        history_records[current_date] = {
                            'asset': asset,
                            'date': current_date,
                            'open_price': last_close_price,
                            'close_price': last_close_price,
                            'high_price': last_close_price,
                            'low_price': last_close_price,
                            'volume': 0,  # No volume on weekends
                            'price': last_close_price,
                            'change_24h': 0,  # No change on weekends
                        }
                    current_date += timedelta(days=1)
                # Insert data into the database
                PriceHistory.objects.bulk_create(
                    [PriceHistory(**record) for record in history_records.values()],
                    ignore_conflicts=True
                )
        except Exception as e:
            print(f"Error fetching historical data for {symbol}: {e}")

    def get_market_cap(self, coingecko_id):
        """
        Fetch the market cap of a cryptocurrency using the CoinGecko API.

        :param coingecko_id: The CoinGecko ID of the cryptocurrency (e.g., 'bitcoin' for BTC)
        :return: Market cap in USD or None if an error occurs.
        """
        try:
            data = self.cg.get_coin_market_chart_by_id(id=coingecko_id, vs_currency='usd', days=1)
            market_cap = data['market_caps'][0][1]
            return market_cap
        except Exception as e:
            print(f"Error fetching market cap for {coingecko_id}: {e}")
            return None


路径: ../backend/portfolio_backend/asgi.py
代码内容:
import os
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'portfolio_backend.settings')

application = get_asgi_application() 

路径: ../backend/portfolio_backend/__init__.py
代码内容:


路径: ../backend/portfolio_backend/settings.py
代码内容:
from pathlib import Path
from datetime import timedelta
import os
from dotenv import load_dotenv

load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent
SECRET_KEY = os.getenv('DJANGO_SECRET_KEY', 'your-default-secret-key')

DEBUG = True

ALLOWED_HOSTS = ['localhost', '127.0.0.1', '0.0.0.0']

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'corsheaders',
    'users', 
    'portfolio',
    'market',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# TEMPLATES
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

ROOT_URLCONF = 'portfolio_backend.urls'
WSGI_APPLICATION = 'portfolio_backend.wsgi.application'

# JWT settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
}

# CORS settings
CORS_ALLOW_ALL_ORIGINS = False
CORS_ALLOWED_ORIGINS = [
    'http://localhost:3000',
    "http://frontend:3000" 
]

# DATABASES
if os.getenv('DOCKER_ENVIRONMENT'):
    # Docker environment settings
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': os.getenv('POSTGRES_DB', 'portfolio'),
            'USER': os.getenv('POSTGRES_USER', 'user'),
            'PASSWORD': os.getenv('POSTGRES_PASSWORD', 'password'),
            'HOST': 'db',
            'PORT': '5432',
        }
    }
else:
    # Local development environment settings
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': BASE_DIR / 'db.sqlite3',
        }
    }

AUTH_USER_MODEL = 'users.User'

# STATIC FILES
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# DEFAULT PRIMARY KEY FIELD
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# LANGUAGE AND TIME ZONE
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'Asia/Singapore'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# LOGGING
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': 'INFO',  
        },
        'portfolio': {
            'handlers': ['console'],
            'level': 'DEBUG', 
            'propagate': True,
        },
    },
}

路径: ../backend/portfolio_backend/urls.py
代码内容:
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('api/users/', include('users.urls')),
    path('api/portfolio/', include('portfolio.urls')), 
    path('api/', include('portfolio.urls')),
    path('api/market/', include('market.urls')),
]

路径: ../backend/portfolio_backend/wsgi.py
代码内容:
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'portfolio_backend.settings')

application = get_wsgi_application() 

